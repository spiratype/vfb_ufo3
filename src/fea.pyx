# coding: future_fstrings
# cython: wraparound=False, boundscheck=False
# cython: infer_types=True, cdivision=True
# cython: optimize.use_switch=True, optimize.unpack_method_calls=True
from __future__ import (absolute_import, division, print_function,
	unicode_literals)

from tools cimport fea_feature, fea_lookup, fea_table

import time

from FL import fl

from vfb_ufo3 import fdk
from vfb_ufo3 import tools
from vfb_ufo3 import vfb
from vfb_ufo3.constants import OT_FEATURES
from vfb_ufo3.future import items, open, range, str, zip

def features(ufo):

	'''
	write fea file
	'''

	font = fl[ufo.ifont]
	start = time.clock()

	if ufo.features.import_groups:
		ot_groups, kern_groups = _font_classes(ufo, font)
	else:
		ot_groups = []

	ot_prefix = [line for line in font.ot_classes.splitlines()
		if line.strip() and not line.startswith('@')]
	ot_prefix = ['\n'.join(elem) for elem in [ot_groups, ot_prefix]]

	if ufo.kern.feature_file:

		with open(ufo.kern.feature_file, 'r') as f:
			kern_feature = str(f.read())

		features = [feature.value.strip() for feature in font.features
			if feature.tag != b'kern']
		features.append(kern_feature)

		features = '\n\n'.join(features)

	elif ufo.features.passthrough_kern:
		features = [feature.value.strip() for feature in font.features]

		features = '\n\n'.join(features)

	elif ufo.features.omit_kern:
		features = [feature.value.strip() for feature in font.features
			if feature.tag != b'kern']

		features = '\n\n'.join(features)

	elif ufo.features.generate_kern:

		if ufo.scale.factor:
			vfb.kerning_scale(ufo, font)

		features = [feature.value.strip() for feature in font.features
			if feature.tag != b'kern']

		kern_feature = str(font.MakeKernFeature().value).replace(';', '')
		kern_feature = _process_kern_feature(kern_feature.splitlines(), ufo)
		if ufo.features.import_groups:
			kern_feature = kern_groups + kern_feature

		kern_feature = fea_feature(kern_feature, 'kern')
		features.append('\n'.join(kern_feature))

	else:
		features = [feature.value.strip() for feature in font.features
			if feature.tag != b'kern']

	if ufo.afdko.parts:
		features = '\n\n'.join([
			'\n\n'.join(_fea_tables(font)),
			'\n\n'.join(ot_prefix),
			'\n'.join(features).replace('\nfeature', '\n\nfeature'),
			])
	else:
		features = '\n\n'.join([
			'\n\n'.join(ot_prefix),
			'\n'.join(features).replace('\nfeature', '\n\nfeature'),
			])

	if ufo.ufoz.ufoz:
		ufo.archive.update({'features.fea': features})
	else:
		tools.write_file(ufo.instance_paths.features, features.strip())

	ufo.instance_times.fea = time.clock() - start

cdef list _fea_tables(object font):

	'''
	features.fea tables
	'''

	cdef:
		list tables = []

	for table in font.truetypetables:
		table = '\n'.join(fea_table(str(table.value).splitlines(), str(table.tag)))
		tables.append(table)

	return tables

cdef tuple _font_classes(object ufo, object font):

	'''
	build OpenType and kern groups from FontLab classes
	'''

	cdef:
		list font_groups, kern_groups

	font_groups = str(font.classes_text).replace('@_', '@').splitlines()
	font_groups = [' '.join(line.split()).replace(' ]', ']') for line in font_groups]
	for i, line in enumerate(font_groups):
		if line.count(ufo.kern.first_prefix) or line.count(ufo.kern.second_prefix):
			split_index = i
			break

	kern_groups = font_groups[split_index:]
	kern_groups = [line for line in sorted(kern_groups)]

	return list(sorted(font_groups[:split_index])), kern_groups

cdef list _process_kern_feature(list kern_feature, object ufo):

	'''
	process kern feature value generated by MakeKernFeature()
	'''

	cdef:
		Py_ssize_t i
		list glyph_glyph_kerning = []
		list enum_kerning = []
		list group_kerning = []
		list removes = []
		unicode line
		unicode enum = 'enum pos'
		unicode pos = 'pos'
		unicode _enum = '$ENUM'
		unicode _pos = '$POS'

	# reformat kern feature for processing
	kern_feature = '\n'.join(kern_feature).replace(enum, _enum).replace(pos, _pos).splitlines()
	kern_feature = [line.strip() for line in kern_feature if line.count('$')]

	# sort kern feature into glyph-glyph, enum, and group-group kerning
	for line in kern_feature:
		if not line.count('@'):
			glyph_glyph_kerning.append(line)
		elif line.count(_enum):
			enum_kerning.append(line)
		else:
			group_kerning.append(line)

	enum_kerning = _add_subtables(enum_kerning)
	group_kerning = _add_subtables(group_kerning)

	kern_feature = glyph_glyph_kerning + enum_kerning + group_kerning

	# check for subtables added too soon
	for i, line in enumerate(kern_feature[:4096]):
		if line.count('subtable'):
			removes.append(i)
			break
	if removes:
		for i in reversed(removes):
			del kern_feature[i]

	kern_feature = [line + ';' for line in kern_feature]

	if len(kern_feature) > 4096:
		kern_feature = fea_lookup(kern_feature, 'kerning', ufo, 1, ['IgnoreMarks'])

	return '\n'.join(kern_feature).replace(_enum, enum).replace(_pos, pos).replace('@_', '@').splitlines()

cdef list _add_subtables(list kerning_set):

	'''
	add subtables in a kerning set
	'''

	cdef:
		Py_ssize_t i, j
		int kerning_set_n = len(kerning_set)
		list subtables

	if kerning_set_n < 5120:
		return kerning_set

	else:
		subtables = [i for i in range(4096, kerning_set_n - 512, 2048)]
		if subtables:
			for i in reversed(subtables):
				j = _subtable_index(kerning_set[i:i+256], i) + 1
				kerning_set.insert(j, 'subtable')

	return kerning_set

cdef Py_ssize_t _subtable_index(list kerning_subset, Py_ssize_t index):

	'''
	find subtable insertion index
	'''

	cdef:
		Py_ssize_t i
		unicode line

	for i, line in enumerate(kerning_subset):
		if line.split()[1] != kerning_subset[i+1].split()[1]:
			return index + i
	return index
